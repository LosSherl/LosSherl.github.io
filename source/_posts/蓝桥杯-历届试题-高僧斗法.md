---
title: 蓝桥杯 历届试题 高僧斗法
date: 2017-03-17 23:00:48
tags:
	- 题解
	- 蓝桥杯
---

问题描述
　　古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。
　　节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。(如图1所示)
　　两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。
　　两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。
　　对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。

<!-- more -->

输入格式
　　输入数据为一行用空格分开的N个整数，表示小和尚的位置。台阶序号从1算起，所以最后一个小和尚的位置即是台阶的总数。（N<100, 台阶总数<1000）
输出格式
　　输出为一行用空格分开的两个整数: A B, 表示把A位置的小和尚移动到B位置。若有多个解，输出A值较小的解，若无解则输出-1。
样例输入
1 5 9
样例输出
1 4
样例输入
1 5 8 10
样例输出
1 3

思路：
  Nim游戏的变形，每个小和尚之间的台阶即为Nim游戏中的单堆石子数。

AC代码：

	#include <iostream>
	using namespace std;

	int a[101] = {0};
	int b[101] = {0};

	int main()
	{
		int i;
		int n;
		int sum = 0;
		while(cin >> i)
		{
			n++;
			a[n] = i;
		}
		
		for(i = 1; i <= n / 2; i++)
		{
			b[i] = a[2 * i] - a[2 * i - 1] - 1;
		}
		
		for(i = 1; i <= n / 2; i++)
		{
			sum ^= b[i];
		}
		
		if(sum == 0)
			cout << -1;
		else
		{
			for(i = 1; i <= n; i++)
			{
				for(int j = 1; j < a[i + 1] - a[i]; j++)
				{
					a[i] += j;
					sum = 0;
					for(int k = 1; k <= n / 2; k++)
					{
						b[k] = a[2 * k] - a[2 * k - 1] - 1;
						sum ^= b[k];
					}
					if(sum == 0)
					{
						cout << a[i] - j << " " << a[i] << endl;
						break;
					}
					a[i] -= j;
				}
			}
		}
		
	}
