[{"title":"","date":"2019-04-11T02:47:11.896Z","path":"2019/04/11/Notes-Deep-learning-based-RecSys-utilizing-visual-content-2/","text":"Notes-Deep learning based RecSys utilizing visual content(2) /** * prism.js Github theme based on GitHub's theme. * @author Sam Clarke */ code[class*=\"language-\"], pre[class*=\"language-\"] { color: #333; background: none; font-family: Consolas, \"Liberation Mono\", Menlo, Courier, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; word-wrap: normal; line-height: 1.4; -moz-tab-size: 8; -o-tab-size: 8; tab-size: 8; -webkit-hyphens: none; -moz-hyphens: none; -ms-hyphens: none; hyphens: none; } /* Code blocks */ pre[class*=\"language-\"] { padding: .8em; overflow: auto; /* border: 1px solid #ddd; */ border-radius: 3px; /* background: #fff; */ background: #f5f5f5; } /* Inline code */ :not(pre) > code[class*=\"language-\"] { padding: .1em; border-radius: .3em; white-space: normal; background: #f5f5f5; } .token.comment, .token.blockquote { color: #969896; } .token.cdata { color: #183691; } .token.doctype, .token.punctuation, .token.variable, .token.macro.property { color: #333; } .token.operator, .token.important, .token.keyword, .token.rule, .token.builtin { color: #a71d5d; } .token.string, .token.url, .token.regex, .token.attr-value { color: #183691; } .token.property, .token.number, .token.boolean, .token.entity, .token.atrule, .token.constant, .token.symbol, .token.command, .token.code { color: #0086b3; } .token.tag, .token.selector, .token.prolog { color: #63a35c; } .token.function, .token.namespace, .token.pseudo-element, .token.class, .token.class-name, .token.pseudo-class, .token.id, .token.url-reference .token.variable, .token.attr-name { color: #795da3; } .token.entity { cursor: help; } .token.title, .token.title .token.punctuation { font-weight: bold; color: #1d3e81; } .token.list { color: #ed6a43; } .token.inserted { background-color: #eaffea; color: #55a532; } .token.deleted { background-color: #ffecec; color: #bd2c00; } .token.bold { font-weight: bold; } .token.italic { font-style: italic; } /* JSON */ .language-json .token.property { color: #183691; } .language-markup .token.tag .token.punctuation { color: #333; } /* CSS */ code.language-css, .language-css .token.function { color: #0086b3; } /* YAML */ .language-yaml .token.atrule { color: #63a35c; } code.language-yaml { color: #183691; } /* Ruby */ .language-ruby .token.function { color: #333; } /* Markdown */ .language-markdown .token.url { color: #795da3; } /* Makefile */ .language-makefile .token.symbol { color: #795da3; } .language-makefile .token.variable { color: #183691; } .language-makefile .token.builtin { color: #0086b3; } /* Bash */ .language-bash .token.keyword { color: #0086b3; } /* highlight */ pre[data-line] { position: relative; padding: 1em 0 1em 3em; } pre[data-line] .line-highlight-wrapper { position: absolute; top: 0; left: 0; background-color: transparent; display: block; width: 100%; } pre[data-line] .line-highlight { position: absolute; left: 0; right: 0; padding: inherit 0; margin-top: 1em; background: hsla(24, 20%, 50%,.08); background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0)); pointer-events: none; line-height: inherit; white-space: pre; } pre[data-line] .line-highlight:before, pre[data-line] .line-highlight[data-end]:after { content: attr(data-start); position: absolute; top: .4em; left: .6em; min-width: 1em; padding: 0 .5em; background-color: hsla(24, 20%, 50%,.4); color: hsl(24, 20%, 95%); font: bold 65%/1.5 sans-serif; text-align: center; vertical-align: .3em; border-radius: 999px; text-shadow: none; box-shadow: 0 1px white; } pre[data-line] .line-highlight[data-end]:after { content: attr(data-end); top: auto; bottom: .4em; }html body{font-family:\"Helvetica Neue\",Helvetica,\"Segoe UI\",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:\"\\00a0\"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for=\"preview\"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for=\"preview\"]) .code-chunk .status{display:none}.markdown-preview:not([for=\"preview\"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for=\"html-export\"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=\"html-export\"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for=\"html-export\"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px)}}@media screen and (max-width:914px){html body[for=\"html-export\"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=\"html-export\"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for=\"html-export\"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=\"html-export\"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=\"html-export\"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=\"html-export\"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=\"html-export\"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none} /* Please visit the URL below for more information: */ /* https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */ &#x53C2;&#x8003;&#x6587;&#x732E; [1] Li Z , Zhao H , Liu Q , et al. Learning from History and Present: Next-item Recommendation via Discriminatively Exploiting User Behaviors[J]. 2018. (KDD) [2] Learning from History and Present: Next-item Recommendation via Discriminatively Exploiting User Behaviors &#x4ECB;&#x7ECD; &#x7535;&#x5B50;&#x5546;&#x52A1;&#x4E2D;&#xFF0C;&#x987E;&#x5BA2;&#x7684;&#x884C;&#x4E3A;&#x5305;&#x542B;&#x4E86;&#x5927;&#x91CF;&#x4FE1;&#x606F;&#xFF0C;&#x5305;&#x62EC;&#x6D88;&#x8D39;&#x4E60;&#x60EF;&#xFF0C;&#x53D8;&#x5316;&#x7684;&#x504F;&#x597D;&#x7B49;&#xFF0C;session-based&#x7684;&#x63A8;&#x8350;&#x8D8A;&#x6765;&#x8D8A;&#x6D41;&#x884C;&#x3002;&#x6587;&#x7AE0;&#x6307;&#x51FA;&#x73B0;&#x6709;&#x7814;&#x7A76;&#x5DE5;&#x4F5C;&#x4EC5;&#x5173;&#x6CE8;&#x4E86;&#x77ED;&#x671F;&#x5185;&#x7684;&#x884C;&#x4E3A;&#xFF0C;&#x5FFD;&#x7565;&#x4E86;&#x7528;&#x6237;&#x7684;&#x957F;&#x671F;&#x504F;&#x597D;&#x548C;&#x6F14;&#x5316;&#x8FC7;&#x7A0B;&#x3002;&#x63D0;&#x51FA;&#x4E86;Behavior-Intensive Neural Network(BINN)&#xFF0C;&#x901A;&#x8FC7;&#x7ED3;&#x5408;&#x7528;&#x6237;&#x7684;&#x957F;&#x671F;&#x504F;&#x597D;&#x548C;&#x5F53;&#x524D;&#x6D88;&#x8D39;&#x52A8;&#x673A;&#x5BF9;&#x4E0B;&#x4E00;&#x4EF6;&#x8BBF;&#x95EE;&#x7684;&#x7269;&#x54C1;&#x8FDB;&#x884C;&#x63A8;&#x8350;&#x3002;&#x6A21;&#x578B;&#x5305;&#x542B;&#x4E24;&#x4E2A;&#x7EC4;&#x4EF6;&#xFF0C;&#x5176;&#x4E00;&#x662F;&#x57FA;&#x4E8E;&#x7528;&#x6237;&#x4EA4;&#x4E92;&#x7528;&#x4E8E;&#x83B7;&#x5F97;&#x7269;&#x54C1;&#x7EDF;&#x4E00;&#x8868;&#x793A;&#x7684;&#x5D4C;&#x5165;&#x65B9;&#x6CD5;&#xFF0C;&#x5176;&#x4E8C;&#x662F;&#x57FA;&#x4E8E;&#x5D4C;&#x5165;&#x7269;&#x54C1;&#x4EE5;&#x53CA;&#x4EA4;&#x4E92;&#x5E8F;&#x5217;&#x7684;&#x5224;&#x522B;&#x884C;&#x4E3A;&#x5B66;&#x4E60;&#xFF0C;&#x5B66;&#x4E60;&#x76EE;&#x6807;&#x7528;&#x6237;&#x5386;&#x53F2;&#x504F;&#x597D;&#x548C;&#x5F53;&#x524D;&#x52A8;&#x673A;&#x3002;&#x56FE;1&#x5C55;&#x793A;&#x4E86;&#x6587;&#x7AE0;&#x7684;&#x601D;&#x60F3;&#x3002; &#x4E0E;&#x4F20;&#x7EDF;&#x57FA;&#x4E8E;&#x6587;&#x672C;&#x6216;&#x56FE;&#x7247;&#x7684;&#x5D4C;&#x5165;&#x65B9;&#x6CD5;&#x4E0D;&#x540C;&#xFF0C;&#x6587;&#x7AE0;&#x4E2D;&#x63D0;&#x51FA;&#x7684;&#x5D4C;&#x5165;&#x65B9;&#x6CD5;&#x76F4;&#x63A5;&#x5229;&#x7528;&#x7528;&#x6237;&#x4E0E;&#x7269;&#x54C1;&#x7684;&#x4EA4;&#x4E92;&#x5E8F;&#x5217;&#x3002;&#x5BF9;&#x4E8E;&#x7B2C;&#x4E8C;&#x4E2A;&#x7EC4;&#x4EF6;&#xFF0C;&#x6587;&#x7AE0;&#x4E2D;&#x7528;&#x4E24;&#x4E2A;&#x6DF1;&#x5C42;&#x7F51;&#x7EDC;&#x5171;&#x540C;&#x5730;&#x5B66;&#x4E60;&#x7528;&#x6237;&#x7684;&#x5F53;&#x524D;&#x52A8;&#x673A;&#x4E0E;&#x5386;&#x53F2;&#x504F;&#x597D;&#x3002;&#x6700;&#x7EC8;&#xFF0C;&#x5019;&#x9009;&#x7269;&#x54C1;&#x4E5F;&#x6620;&#x5C04;&#x5230;&#x540C;&#x4E00;&#x9690;&#x7A7A;&#x95F4;&#x4E2D;&#xFF0C;&#x7531;BINN&#x4E3A;&#x7528;&#x6237;&#x751F;&#x6210;&#x63A8;&#x8350;&#xFF0C;&#x6574;&#x4F53;&#x7ED3;&#x6784;&#x5982;&#x56FE;2&#x6240;&#x793A;&#x3002; &#x7269;&#x54C1;&#x5D4C;&#x5165;&#x65B9;&#x6CD5;(w-item2vec) w-item2vec&#x901A;&#x8FC7;&#x7269;&#x54C1;&#x8BBF;&#x95EE;&#x5E8F;&#x5217;&#x4E60;&#x5F97;&#x7269;&#x54C1;&#x95F4;&#x7684;&#x76F8;&#x4F3C;&#x5EA6;&#xFF0C;&#x4ECE;&#x800C;&#x5F97;&#x5230;&#x6BCF;&#x4E2A;&#x7269;&#x54C1;&#x7684;&#x5411;&#x91CF;&#x8868;&#x793A;&#xFF0C;&#x6838;&#x5FC3;&#x601D;&#x60F3;&#x662F;&#x8868;&#x73B0;&#x51FA;&#x76F8;&#x4F3C;&#x5438;&#x5F15;&#x6027;&#xFF08;&#x8BBF;&#x95EE;&#x5E8F;&#x5217;&#x76F8;&#x4F3C;&#xFF09;&#x7684;&#x7269;&#x54C1;&#x5F80;&#x5F80;&#x5F88;&#x76F8;&#x4F3C;&#x3002;&#x53D7;Item2vec&#x542F;&#x53D1;&#xFF0C;w-item2vec&#x4E5F;&#x4F7F;&#x7528;&#x4E86;Skip-gram model with Negative Sampling&#xFF0C;w-item2vec&#x4E2D;&#x7684;Skip-gram&#x6700;&#x5927;&#x5316;&#x7684;&#x76EE;&#x6807;&#x51FD;&#x6570;&#x5982;&#x516C;&#x5F0F;1&#xFF0C;&#x52A0;&#x5165;&#x8D1F;&#x91C7;&#x6837;&#xFF0C;&#x5E76;&#x5C06;&#x7269;&#x54C1;&#x5728;&#x5E8F;&#x5217;&#x4E2D;&#x7684;&#x9891;&#x5EA6;&#x4F5C;&#x4E3A;&#x91C7;&#x6837;&#x6743;&#x91CD;&#x540E;&#xFF0C;&#x6700;&#x7EC8;&#x7684;&#x76EE;&#x6807;&#x51FD;&#x6570;&#x5982;&#x516C;&#x5F0F;5&#x6240;&#x793A;&#xFF0C;&#x5176;&#x4E2D;w&#x4E3A;&#x7269;&#x54C1;&#x7684;&#x5411;&#x91CF;&#x8868;&#x793A;&#xFF0C;v&#x4E3A;&#x4E0A;&#x4E0B;&#x6587;&#x7269;&#x54C1;&#x7684;&#x5411;&#x91CF;&#x8868;&#x793A;&#x3002; Discriminative Behaviors Learning &#x8BE5;&#x7EC4;&#x4EF6;&#x5305;&#x542B;&#x4E24;&#x4E2A;&#x57FA;&#x4E8E;LSTM&#x7684;&#x7F51;&#x7EDC;&#xFF0C;&#x7528;&#x4E8E;&#x5B66;&#x4E60;&#x7528;&#x6237;&#x7684;&#x77ED;&#x671F;&#x52A8;&#x673A;&#x548C;&#x957F;&#x671F;&#x504F;&#x597D;&#x3002;&#x4E24;&#x4E2A;&#x7F51;&#x7EDC;&#x7684;&#x8F93;&#x51FA;&#x7ECF;&#x8FC7;&#x4E00;&#x4E2A;&#x5168;&#x8FDE;&#x63A5;&#x5C42;&#x540E;&#x751F;&#x6210;&#x4E00;&#x4E2A;d&#x7EF4;&#x5411;&#x91CF;&#xFF0C;&#x4E3A;&#x4E0B;&#x4EF6;&#x7269;&#x54C1;&#x8FDB;&#x884C;&#x63A8;&#x8350;&#x3002; Session Behaviors Learning(SBL) &#x5982;&#x56FE;2&#x6240;&#x793A;&#xFF0C;SBL&#x4E2D;&#x7684;&#x6BCF;&#x4E00;&#x4E2A;&#x9690;&#x72B6;&#x6001;&#x7531;&#x4E0A;&#x4E00;&#x65F6;&#x523B;&#x9690;&#x72B6;&#x6001;&#x3001;&#x5F53;&#x524D;&#x7269;&#x54C1;&#x5411;&#x91CF;&#x3001;&#x4EA4;&#x4E92;&#x52A8;&#x4F5C;(one-hot&#x5411;&#x91CF;)&#x66F4;&#x65B0;&#xFF0C;ts&#x6307;&#x793A;session&#x7684;&#x957F;&#x5EA6;&#xFF0C;&#x9ED8;&#x8BA4;&#x4E3A;10&#xFF0C;&#x6700;&#x7EC8;SBL&#x7684;&#x8F93;&#x51FA;&#x4E3A;t-1&#x65F6;&#x523B;&#x7684;&#x9690;&#x72B6;&#x6001;&#x3002; Preference Behaviors Learning(PBL) &#x8BE5;&#x7F51;&#x7EDC;&#x8BD5;&#x56FE;&#x5BF9;&#x7528;&#x6237;&#x957F;&#x671F;&#x7684;&#x504F;&#x597D;&#x8FDB;&#x884C;&#x5EFA;&#x6A21;&#xFF0C;&#x8003;&#x8651;&#x7528;&#x6237;&#x5386;&#x53F2;&#x504F;&#x597D;&#x7269;&#x54C1;&#xFF08;&#x6DFB;&#x52A0;&#x8D2D;&#x7269;&#x8F66;&#x3001;&#x8D2D;&#x4E70;&#x3001;&#x6536;&#x85CF;&#x7B49;&#xFF09;&#x3002;&#x7531;&#x4E8E;&#x957F;&#x671F;&#x504F;&#x597D;&#x6CE2;&#x52A8;&#x4E0D;&#x5927;&#xFF0C;&#x56E0;&#x6B64;SBL&#x7684;&#x7F51;&#x7EDC;&#x7ED3;&#x679C;&#x4E0D;&#x9002;&#x7528;&#x4E8E;PBL&#xFF0C;PBL&#x91C7;&#x7528;&#x4E86;&#x7C7B;&#x4F3C;&#x53CC;&#x5411;LSTM&#x7684;&#x7ED3;&#x6784;&#xFF0C;&#x66F4;&#x65B0;&#x65B9;&#x5F0F;&#x4E0E;SBL&#x7C7B;&#x4F3C;&#x3002;&#x6BCF;&#x4E2A;&#x65F6;&#x523B;&#x7684;&#x9690;&#x72B6;&#x6001;&#x7531;&#x524D;&#x5411;&#x548C;&#x540E;&#x5411;&#x7684;&#x9690;&#x72B6;&#x6001;&#x5411;&#x91CF;&#x8FDE;&#x63A5;&#x5F97;&#x5230;&#xFF0C;PBL&#x6700;&#x7EC8;&#x8F93;&#x51FA;&#x4E3A;&#x5404;&#x65F6;&#x523B;&#x7684;&#x9690;&#x72B6;&#x6001;&#x5747;&#x503C;&#x3002; &#x6A21;&#x578B;&#x8BAD;&#x7EC3; &#x8BAD;&#x7EC3;&#x91C7;&#x7528;&#x5747;&#x65B9;&#x8BEF;&#x5DEE;&#x4F5C;&#x4E3A;&#x635F;&#x5931;&#x51FD;&#x6570;&#xFF0C;&#x5982;&#x516C;&#x5F0F;10&#x6240;&#x793A;&#x3002;&#x751F;&#x6210;k&#x7EF4;&#x5411;&#x91CF;v&#x540E;&#xFF0C;&#x5728;&#x5D4C;&#x5165;&#x7A7A;&#x95F4;&#x4E2D;&#x8BA1;&#x7B97;v&#x4E0E;&#x5176;&#x4ED6;&#x7269;&#x54C1;&#x8868;&#x793A;&#x7684;&#x76F8;&#x4F3C;&#x5EA6;&#xFF0C;&#x5C06;&#x6700;&#x76F8;&#x4F3C;&#x7684;&#x524D;k&#x4E2A;&#x7269;&#x54C1;&#x4F5C;&#x4E3A;&#x63A8;&#x8350;&#x3002; &#x5B9E;&#x9A8C; &#x5B9E;&#x9A8C;&#x91C7;&#x7528;&#x4E86;&#x4EAC;&#x4E1C;&#x548C;&#x5929;&#x6C60;(https://tianchi.aliyun.com/getStart/information.htm?spm=5176.100067.5678.2.30a8b6d933N6Rr&amp;raceId=231522)&#x6570;&#x636E;&#x96C6;&#x3002;&#x7531;&#x4E8E;&#x52A0;&#x5165;&#x4E86;&#x9891;&#x5EA6;&#x4F5C;&#x4E3A;&#x8D1F;&#x91C7;&#x6837;&#x6743;&#x91CD;&#xFF0C;w-item2vec&#x7684;&#x8868;&#x73B0;&#x4F18;&#x4E8E;item2vec&#x3002;&#x8BC4;&#x6D4B;&#x5C3A;&#x5EA6;&#x91C7;&#x7528;Recall@20&#x548C;MRR@20&#xFF0C;&#x6839;&#x636E;&#x4E0E;&#x5176;&#x4ED6;&#x6A21;&#x578B;&#x7684;&#x6BD4;&#x8F83;&#x5B9E;&#x9A8C;&#x7ED3;&#x679C;&#xFF0C;&#x5F3A;&#x8C03;&#x4E86;&#x5BF9;&#x7528;&#x6237;&#x957F;&#x671F;&#x504F;&#x597D;&#x8FDB;&#x884C;&#x5EFA;&#x6A21;&#x7684;&#x6709;&#x6548;&#x6027;&#x3002;&#x5BF9;&#x4E8E;&#x51B7;&#x542F;&#x52A8;&#x95EE;&#x9898;&#xFF0C;&#x5B9E;&#x9A8C;&#x4E2D;&#x7528;&#x9884;&#x8BAD;&#x7EC3;&#x7684;&#x6A21;&#x578B;fit&#x65B0;&#x7528;&#x6237;&#xFF0C;&#x4ECE;&#x7B2C;&#x4E8C;&#x4E2A;&#x4EA4;&#x4E92;&#x5F00;&#x59CB;&#x9884;&#x6D4B;&#xFF0C;&#x5B9E;&#x9A8C;&#x4E2D;&#x53D1;&#x73B0;&#x6DF1;&#x5EA6;&#x5B66;&#x4E60;&#x6A21;&#x578B;&#x80FD;&#x591F;&#x8F83;&#x597D;&#x5730;&#x9762;&#x5BF9;&#x51B7;&#x542F;&#x52A8;&#x73B0;&#x8C61;&#x3002;&#x6B64;&#x5916;&#xFF0C;&#x5728;&#x5BF9;&#x7528;&#x6237;&#x5386;&#x53F2;&#x504F;&#x597D;&#x5EFA;&#x6A21;&#x5206;&#x6790;&#x4E2D;&#xFF0C;&#x5229;&#x7528;&#x7684;&#x5386;&#x53F2;&#x4EA4;&#x4E92;&#x6B21;&#x6570;&#x8D8A;&#x591A;&#x6A21;&#x578B;&#x8868;&#x73B0;&#x8D8A;&#x597D;&#x3002;","tags":[]},{"title":"Notes-Deep learning based RecSys utilizing visual content(2)","date":"2019-04-09T08:10:25.000Z","path":"2019/04/09/Notes-Deep-learning-based-RecSys-utilizing-visual-content-2/","text":"参考文献[1] Li Z , Zhao H , Liu Q , et al. Learning from History and Present: Next-item Recommendation via Discriminatively Exploiting User Behaviors[J]. 2018. (KDD)[2] Learning from History and Present: Next-item Recommendation via Discriminatively Exploiting User Behaviors介绍电子商务中，顾客的行为包含了大量信息，包括消费习惯，变化的偏好等，session-based的推荐越来越流行。文章指出现有研究工作仅关注了短期内的行为，忽略了用户的长期偏好和演化过程。提出了Behavior-Intensive Neural Network(BINN)，通过结合用户的长期偏好和当前消费动机对下一件访问的物品进行推荐。模型包含两个组件，其一是基于用户交互用于获得物品统一表示的嵌入方法，其二是基于嵌入物品以及交互序列的判别行为学习，学习目标用户历史偏好和当前动机。图1展示了文章的思想。与传统基于文本或图片的嵌入方法不同，文章中提出的嵌入方法直接利用用户与物品的交互序列。对于第二个组件，文章中用两个深层网络共同地学习用户的当前动机与历史偏好。最终，候选物品也映射到同一隐空间中，由BINN为用户生成推荐，整体结构如图2所示。 物品嵌入方法(w-item2vec)w-item2vec通过物品访问序列习得物品间的相似度，从而得到每个物品的向量表示，核心思想是表现出相似吸引性（访问序列相似）的物品往往很相似。受Item2vec启发，w-item2vec也使用了Skip-gram model with Negative Sampling，w-item2vec中的Skip-gram最大化的目标函数如公式1，加入负采样，并将物品在序列中的频度作为采样权重后，最终的目标函数如公式5所示，其中w为物品的向量表示，v为上下文物品的向量表示。 Discriminative Behaviors Learning该组件包含两个基于LSTM的网络，用于学习用户的短期动机和长期偏好。两个网络的输出经过一个全连接层后生成一个d维向量，为下件物品进行推荐。 Session Behaviors Learning(SBL)如图2所示，SBL中的每一个隐状态由上一时刻隐状态、当前物品向量、交互动作(one-hot向量)更新，ts指示session的长度，默认为10，最终SBL的输出为t-1时刻的隐状态。 Preference Behaviors Learning(PBL)该网络试图对用户长期的偏好进行建模，考虑用户历史偏好物品（添加购物车、购买、收藏等）。由于长期偏好波动不大，因此SBL的网络结果不适用于PBL，PBL采用了类似双向LSTM的结构，更新方式与SBL类似。每个时刻的隐状态由前向和后向的隐状态向量连接得到，PBL最终输出为各时刻的隐状态均值。 模型训练训练采用均方误差作为损失函数，如公式10所示。生成k维向量v后，在嵌入空间中计算v与其他物品表示的相似度，将最相似的前k个物品作为推荐。 实验实验采用了京东和天池数据集。由于加入了频度作为负采样权重，w-item2vec的表现优于item2vec。评测尺度采用Recall@20和MRR@20，根据与其他模型的比较实验结果，强调了对用户长期偏好进行建模的有效性。对于冷启动问题，实验中用预训练的模型fit新用户，从第二个交互开始预测，实验中发现深度学习模型能够较好地面对冷启动现象。此外，在对用户历史偏好建模分析中，利用的历史交互次数越多模型表现越好。 天池数据集：https://tianchi.aliyun.com/competition/entrance/231522/information","tags":[{"name":"RecSys","slug":"RecSys","permalink":"http://lossherl.club/tags/RecSys/"},{"name":"User preference modeling","slug":"User-preference-modeling","permalink":"http://lossherl.club/tags/User-preference-modeling/"}]},{"title":"Notes-Deep learning based RecSys utilizing visual content(1)","date":"2019-04-04T02:02:03.000Z","path":"2019/04/04/Notes-Deep-learning-based-RecSys-utilizing-visual-content-1/","text":"参考文献[1] Zhou J, Albatal R, Gurrin C. Applying Visual User Interest Profiles for Recommendation and Personalisation.[J]. 2016. (MMM)[2] Lei C , Liu D , Li W , et al. Comparative Deep Learning of Hybrid Representations for Image Recommendations[J]. 2016. (CVPR) Applying Visual User Interest Profiles for Recommendation and Personalisation介绍文献[1]认为用户的兴趣偏好可以从其曾经发布的照片中获取，通过使用深度学习中的技术从图片集中获取用户的视觉偏好信息，并用于酒店推荐及页面个性化定制。 视觉特征提取在基于内容的图片检索领域中，一些诸如颜色、文本等低级语义信息被用于表示图像以及计算图像相似度，但是这些低级语义并不能很好地表示用户偏好。文献[1]假设通过结合深度学习，对用户特征进行更高语义层面的提取将使得基于内容的推荐更加有效。文章中的方法利用AlexNet对图像作特征提取，将分类结果（1000个类别的概率分布）作为图像特征。 利用用户偏好文章使用余弦距离作图片间的相似度估计，如公式(1)所示。因此，通过计算用户偏好档案中的图像特征向量与其余图像的特征向量的相似度，获得与用户偏好相近的图片。用户偏好档案由多个图像的特征表示组成。 应用应用于酒店推荐以及酒店页面个性化定制,推荐最近邻图片对应的酒店，没有相关实验结果介绍。 Comparative Deep Learning of Hybrid Representations for Image Recommendations介绍诸如图片推荐等以用户为中心的任务不仅需要高效的图片表示，还需要对用户的偏好和意图进行表示。文章提出的方法将用户和图片映射到同一隐空间中，再通过计算图片表示与用户表示的距离做决策。文章还提出一种名为比较深度学习(CDL)的方法，在不增加额外计算代价的前提下，使用了更多的训练数据，取得了比传统训练方法更好的效果，超越了state of the art图片推荐系统。文章提出的模型包含两个深度网络，分别抽取图片和用户偏好表示，CDL方法使用三元组(用户、正例图片，反例图片)做输入，学习正反例照片的相对距离，如图1所示。 相关研究图片表示学习 有监督哈希方法，在深度学习框架下同时学习哈希函数和图片表示。 深度学习模型（图片分类模型）的中层输出。 对于以用户为中心的应用，不仅需要考虑图片表示，用户的偏好也具有极大价值。 同时考虑图片相似度和用户的社交关系学习一种新的距离度量，但需要精细的人工特征选择。 以用户间的相似度对用户意图进行建模。 以三元组进行训练的效果好过单一图片。 个性化图片推荐 结合当地社区用户评分的概率矩阵分解方法。 使用双因素回归的矩阵分解方法捕获用户社交属性上述方法仅关注用户的行为模式忽略了图片因素。 结合用户偏好和上传照片的主题模型，用于学习社交网络中用户的影响力。 基于社交嵌入的图片表示的投票方法。 比较学习在社交网络中，用户对于图片的负向反馈十分匮乏，因此，使用传统方法训练的效果十分受限。文章中提出的比较学习方法，以公式1所示的三元组集合作为输入，目标是习得图片和用户偏好的映射函数，满足公式2，即相对反例图片，用户偏好向量与正例图片的向量表示的距离更近。其中距离尺度可以是简单的欧几里得距离，为了使正反例图片表示的距离尽可能地远，进一步采用交叉熵作为损失函数，相关定义如公式3，4，5。 双网络结构如图2所示，上方与下方的网络分别用于抽取正反例图片的表示，有着相同定义(类似AlexNet)并共享参数。中间的网络用于捕获用户的偏好信息，由多个全连接层组成，网络的输入向量需要人为的特征选择。使用CDL方法的有两个需要解决的问题，一是如何对用户数据进行预处理生成输入用户向量，二是如何准备训练集中的三元组。对于第一个问题，由于用户标签过于稀疏，文章中采用的方法是将标签通过word2vec映射成向量，再将所有标签向量通过k均值算法聚成1024个聚类，因此用户可以表示成1024维的向量。对于第二个问题，正例图片可通过用户点赞行为获取，对于反例图片，因为用户未点赞的图片未必是用户不喜欢的（可能从未见过），文章中通过融入社交关系，从作者未点赞的图片和好友社区也未点赞的图片集中采样反例图片，从而生成训练所需的三元组。推荐时，首先选择一个候选集，候选集中的图片至少拥有一个用户喜好的标签，然后将用户与图片同时映射到同一隐空间中，用K近邻算法获取推荐图片列表。 实验实验使用在Flickr上爬取的数据集，包含101496张图片，54173个用户，6439个群组，35844个图片标签，平均每位用户有23.5给喜好标签和5.8张点赞图片。由于数据集过于稀疏，无法使用如协同过滤等传统算法进行推荐，故未与此类算法进行比较。比较实验结果如图5，6所示，由实验结果可见应用交叉熵损失的CDL效果好过使用铰链损失，基于人工特征提取的BoW和LMNN方法表现极差，BoW预测精度接近随机猜测，应用ImageNet特征的SIDL取得了第三好的结果，体现了深度学习的优势。通过融入社交信息，LMNN的表现提高显著。","tags":[{"name":"RecSys","slug":"RecSys","permalink":"http://lossherl.club/tags/RecSys/"},{"name":"User preference modeling","slug":"User-preference-modeling","permalink":"http://lossherl.club/tags/User-preference-modeling/"}]},{"title":"hihoCoder 1290 Demo Day","date":"2017-03-22T16:25:25.000Z","path":"2017/03/23/hihoCoder-1290-Demo-Day/","text":"描述You work as an intern at a robotics startup. Today is your company’s demo day. During the demo your company’s robot will be put in a maze and without any information about the maze, it should be able to find a way out. The maze consists of N * M grids. Each grid is either empty(represented by ‘.’) or blocked by an obstacle(represented by ‘b’). The robot will be release at the top left corner and the exit is at the bottom right corner. Unfortunately some sensors on the robot go crazy just before the demo starts. As a result, the robot can only repeats two operations alternatively: keep moving to the right until it can’t and keep moving to the bottom until it can’t. At the beginning, the robot keeps moving to the right. rrrrbb..…r…. ====&gt; The robot route with broken sensors is marked by ‘r’.…rrb..…bb…While the FTEs(full-time employees) are busy working on the sensors, you try to save the demo day by rearranging the maze in such a way that even with the broken sensors the robot can reach the exit successfully. You can change a grid from empty to blocked and vice versa. So as not to arouse suspision, you want to change as few grids as possible. What is the mininum number? 输入Line 1: N, M. Line 2-N+1: the N * M maze. For 20% of the data, N * M &lt;= 16. For 50% of the data, 1 &lt;= N, M &lt;= 8. For 100% of the data, 1&lt;= N, M &lt;= 100. 输出The minimum number of grids to be changed. 样例输入4 8….bb..……..…..b..…bb…样例输出1 思路： 动态规划，dp[i][j][k]表示到达(i,j)点以k方向前进最小所需做改变的次数。 代码: #include &lt;iostream&gt; using namespace std; int m,n; bool map[110][110] = {0}; int dp[110][110][2] = {0}; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { char c; cin &gt;&gt; c; if(c == &apos;.&apos;) { map[i][j] = true; } } } for(int i = 0; i &lt;= n; i++) { for(int j = 0; j &lt;= m; j++) { dp[i][j][0] = dp[i][j][1] = 999999; } } dp[1][1][0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { for(int k = 0; k &lt; 2; k++) { if(map[i][j]) { if(k) { dp[i][j][k] = min(dp[i][j][k],dp[i - 1][j][k]); if(!map[i + 1][j]) { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k]); } else { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k] + 1); } } else { dp[i][j][k] = min(dp[i][j][k],dp[i][j - 1][k]); if(!map[i][j + 1]) { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k]); } else { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k] + 1); } } } else { if(k) { dp[i][j][k] = min(dp[i][j][k],dp[i - 1][j][k] + 1); if(!map[i + 1][j]) { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k]); } else { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k] + 1); } } else { dp[i][j][k] = min(dp[i][j][k],dp[i][j - 1][k] + 1); if(!map[i][j + 1]) { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k]); } else { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k] + 1); } } } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; dp[i][j][k] &lt;&lt; endl; } } } cout &lt;&lt; min(dp[n][m][0],dp[n][m][1]) &lt;&lt; endl; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://lossherl.club/tags/hihoCoder/"}]},{"title":"hihoCoder 1238 Total Highway Distance","date":"2017-03-21T14:28:30.000Z","path":"2017/03/21/hihoCoder-1238-Total-Highway-Distance/","text":"时间限制:10000ms单点时限:1000ms内存限制:256MB描述Little Hi and Little Ho are playing a construction simulation game. They build N cities (numbered from 1 to N) in the game and connect them by N-1 highways. It is guaranteed that each pair of cities are connected by the highways directly or indirectly. The game has a very important value called Total Highway Distance (THD) which is the total distances of all pairs of cities. Suppose there are 3 cities and 2 highways. The highway between City 1 and City 2 is 200 miles and the highway between City 2 and City 3 is 300 miles. So the THD is 1000(200 + 500 + 300) miles because the distances between City 1 and City 2, City 1 and City 3, City 2 and City 3 are 200 miles, 500 miles and 300 miles respectively. During the game Little Hi and Little Ho may change the length of some highways. They want to know the latest THD. Can you help them? 输入Line 1: two integers N and M. Line 2 .. N: three integers u, v, k indicating there is a highway of k miles between city u and city v. Line N+1 .. N+M: each line describes an operation, either changing the length of a highway or querying the current THD. It is in one of the following format. EDIT i j k, indicating change the length of the highway between city i and city j to k miles. QUERY, for querying the THD. For 30% of the data: 2&lt;=N&lt;=100, 1&lt;=M&lt;=20 For 60% of the data: 2&lt;=N&lt;=2000, 1&lt;=M&lt;=20 For 100% of the data: 2&lt;=N&lt;=100,000, 1&lt;=M&lt;=50,000, 1 &lt;= u, v &lt;= N, 0 &lt;= k &lt;= 1000. 输出For each QUERY operation output one line containing the corresponding THD. 样例输入3 51 2 22 3 3QUERYEDIT 1 2 4QUERYEDIT 2 3 2QUERY样例输出101412 思路： 两次深搜计算每条路径经过的次数。 代码： #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cstdio&gt; using namespace std; typedef struct p{ int cur; vector&lt;int&gt; v; p(int c) { cur = c; } }p; typedef struct ar{ int to; int index; ar(int t,int i) { to = t; index = i; } }ar; typedef struct arcc{ int f; int t; int v; }arcc; vector&lt;ar&gt; a[100010]; bool vi[100010] = {0}; arcc arc[100010]; long long arc_c[100010] = {0}; int n,m; int child[100010] = {0}; long long query() { long long ans = 0; for(int i = 1; i &lt; n; i++) { ans += arc[i].v * arc_c[i]; } return ans; } void dfs(int x,int f) { child[x] = 1; for(int i = 0; i &lt; a[x].size(); i++) { if(a[x][i].to == f) continue; dfs(a[x][i].to,x); child[x] += child[a[x][i].to]; } } void dfs1(int x,int f) { for(int i = 0; i &lt; a[x].size(); i++) { if(a[x][i].to == f) continue; arc_c[a[x][i].index] = (long long) child[a[x][i].to] * (long long)(n - child[a[x][i].to]); dfs1(a[x][i].to,x); } } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt; n; i++) { int f,t,v; scanf(&quot;%d %d %d&quot;,&amp;f,&amp;t,&amp;v); arc[i].v = v; arc[i].f = f; arc[i].t = t; a[f].push_back(ar(t,i)); a[t].push_back(ar(f,i)); } dfs(1,0); dfs1(1,0); // for(int i = 1; i &lt; n; i++) // cout &lt;&lt; arc_c[i] &lt;&lt; endl; string cmd; long long ans = query(); for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; cmd; if(cmd == &quot;QUERY&quot;) { printf(&quot;%lld\\n&quot;,ans); } else { int f,t,v; scanf(&quot;%d %d %d&quot;,&amp;f,&amp;t,&amp;v); for(int j = 0; j &lt; a[f].size(); j++) { if(a[f][j].to == t) { ans += arc_c[a[f][j].index] * (v - arc[a[f][j].index].v); arc[a[f][j].index].v = v; break; } } } } }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://lossherl.club/tags/hihoCoder/"}]},{"title":"hihoCoder 1399 Shortening Sequence","date":"2017-03-21T14:25:14.000Z","path":"2017/03/21/hihoCoder-1399-Shortening-Sequence/","text":"时间限制:10000ms单点时限:1000ms内存限制:256MB描述There is an integer array A1, A2 …AN. Each round you may choose two adjacent integers. If their sum is an odd number, the two adjacent integers can be deleted. Can you work out the minimum length of the final array after elaborate deletions? 输入The first line contains one integer N, indicating the length of the initial array. The second line contains N integers, indicating A1, A2 …AN. For 30% of the data：1 ≤ N ≤ 10 For 60% of the data：1 ≤ N ≤ 1000 For 100% of the data：1 ≤ N ≤ 1000000, 0 ≤ Ai ≤ 1000000000 输出One line with an integer indicating the minimum length of the final array. 样例提示(1,2) (3,4) (4,5) are deleted. 样例输入71 1 2 3 4 4 5样例输出1 思路： 动态规划，线性扫描并枚举26个字母。 代码: #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; using namespace std; //strucc p{ // int cur; // int last; // int len; //}dp[1000001]; int n; int main() { cin &gt;&gt; n; vector&lt;int&gt; v; int t; scanf(&quot;%d&quot;,&amp;t); v.push_back(t); for(int i = 2; i &lt;= n; i++) { scanf(&quot;%d&quot;,&amp;t); if(v.size() == 0) { v.push_back(t); continue; } if((t ^ v[v.size() - 1]) &amp; 1) { v.erase(v.end() - 1); } else v.push_back(t); } cout &lt;&lt; v.size(); }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://lossherl.club/tags/hihoCoder/"}]},{"title":"hihoCoder 1288 Font Size","date":"2017-03-21T14:21:08.000Z","path":"2017/03/21/hihoCoder-1288-Font-Size/","text":"时间限制:10000ms单点时限:1000ms内存限制:256MB描述Steven loves reading book on his phone. The book he reads now consists of N paragraphs and the i-th paragraph contains ai characters. Steven wants to make the characters easier to read, so he decides to increase the font size of characters. But the size of Steven’s phone screen is limited. Its width is W and height is H. As a result, if the font size of characters is S then it can only show ⌊W / S⌋ characters in a line and ⌊H / S⌋ lines in a page. (⌊x⌋ is the largest integer no more than x) So here’s the question, if Steven wants to control the number of pages no more than P, what’s the maximum font size he can set? Note that paragraphs must start in a new line and there is no empty line between paragraphs. 输入Input may contain multiple test cases. The first line is an integer TASKS, representing the number of test cases. For each test case, the first line contains four integers N, P, W and H, as described above. The second line contains N integers a1, a2, … aN, indicating the number of characters in each paragraph. For all test cases, 1 &lt;= N &lt;= 103, 1 &lt;= W, H, ai &lt;= 103, 1 &lt;= P &lt;= 106, There is always a way to control the number of pages no more than P. 输出For each testcase, output a line with an integer Ans, indicating the maximum font size Steven can set. 样例输入21 10 4 3102 10 4 310 10样例输出32 思路： 二分搜索。 代码： #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;queue&gt; using namespace std; int task; int w,h,p; int n; int a[1001] = {0}; int main() { cin &gt;&gt; task; for(int z = 1; z &lt;= task; z++) { cin &gt;&gt; n &gt;&gt; p &gt;&gt; w &gt;&gt; h; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int l = 1; int r = min(w,h); int mid; int last; while(l &lt;= r) { mid = (l + r) / 2; int line = h / mid; int wid = w / mid; int count = 0; for(int j = 1; j &lt;= n; j++) { count += a[j] / wid; if(a[j] % wid) count++; } if(count &lt;= p * line) { last = mid; l = mid + 1; } else { r = mid - 1; } } cout &lt;&lt; last &lt;&lt; endl; } }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://lossherl.club/tags/hihoCoder/"}]},{"title":"蓝桥杯 历届试题 小朋友排队","date":"2017-03-17T15:04:42.000Z","path":"2017/03/17/蓝桥杯-历届试题-小朋友排队/","text":"问题描述 n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。 每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。 如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。 请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。 如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。输入格式 输入的第一行包含一个整数n，表示小朋友的个数。 第二行包含 n 个整数 H1 H2 … Hn，分别表示每个小朋友的身高。输出格式 输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。样例输入33 2 1样例输出9样例说明 首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。数据规模和约定 对于10%的数据， 1&lt;=n&lt;=10； 对于30%的数据， 1&lt;=n&lt;=1000； 对于50%的数据， 1&lt;=n&lt;=10000； 对于100%的数据，1&lt;=n&lt;=100000，0&lt;=Hi&lt;=1000000。 思路： 逆序数+树状数组，每个点左边大于它的个数加上右边小于它的个数等于交换的总次数，使用树状数组统计。 AC代码： #include &lt;iostream&gt; using namespace std; #define N 100100 #define MAX 1000100 int a[MAX] = {0}; int b[MAX] = {0}; int c[N] = {0}; int num[N] = {0}; long long total[N] = {0}; int n; int lowbit(int x) { return x&amp;(-x); } void add(int pos,int *p) { while(pos &lt;= MAX) { p[pos]++; pos += lowbit(pos); } } int sum(int pos,int *p) { int cnt = 0; while(pos &gt; 0) { cnt += p[pos]; pos -= lowbit(pos); } return cnt; } void Init() { for(int i = 1; i &lt;= n; i++) { total[i] = total[i - 1] + i; } } int main() { cin &gt;&gt; n; Init(); for(int i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; add(num[i] + 1,a); c[i] = i - sum(num[i],a); c[i] -= sum(num[i] + 1,a) - sum(num[i],a) - 1; } long long ans = 0; for(int i = n - 1; i &gt;= 0; i--) { add(num[i] + 1,b); c[i] += sum(num[i],b); ans += total[c[i]]; } cout &lt;&lt; ans; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://lossherl.club/tags/蓝桥杯/"}]},{"title":"蓝桥杯 历届试题 高僧斗法","date":"2017-03-17T15:00:48.000Z","path":"2017/03/17/蓝桥杯-历届试题-高僧斗法/","text":"问题描述 古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。 节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。(如图1所示) 两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。 两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。 对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。 输入格式 输入数据为一行用空格分开的N个整数，表示小和尚的位置。台阶序号从1算起，所以最后一个小和尚的位置即是台阶的总数。（N&lt;100, 台阶总数&lt;1000）输出格式 输出为一行用空格分开的两个整数: A B, 表示把A位置的小和尚移动到B位置。若有多个解，输出A值较小的解，若无解则输出-1。样例输入1 5 9样例输出1 4样例输入1 5 8 10样例输出1 3 思路： Nim游戏的变形，每个小和尚之间的台阶即为Nim游戏中的单堆石子数。 AC代码： #include &lt;iostream&gt; using namespace std; int a[101] = {0}; int b[101] = {0}; int main() { int i; int n; int sum = 0; while(cin &gt;&gt; i) { n++; a[n] = i; } for(i = 1; i &lt;= n / 2; i++) { b[i] = a[2 * i] - a[2 * i - 1] - 1; } for(i = 1; i &lt;= n / 2; i++) { sum ^= b[i]; } if(sum == 0) cout &lt;&lt; -1; else { for(i = 1; i &lt;= n; i++) { for(int j = 1; j &lt; a[i + 1] - a[i]; j++) { a[i] += j; sum = 0; for(int k = 1; k &lt;= n / 2; k++) { b[k] = a[2 * k] - a[2 * k - 1] - 1; sum ^= b[k]; } if(sum == 0) { cout &lt;&lt; a[i] - j &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; endl; break; } a[i] -= j; } } } }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://lossherl.club/tags/蓝桥杯/"}]},{"title":"蓝桥杯 历届试题 国王的烦恼","date":"2017-03-17T14:57:12.000Z","path":"2017/03/17/蓝桥杯-历届试题-国王的烦恼/","text":"问题描述 C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。 如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。 现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。输入格式 输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。 接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。输出格式 输出一个整数，表示居民们会抗议的天数。样例输入4 41 2 21 3 22 3 13 4 3样例输出2样例说明 第一天后2和3之间的桥不能使用，不影响。 第二天后1和2之间，以及1和3之间的桥不能使用，居民们会抗议。 第三天后3和4之间的桥不能使用，居民们会抗议。数据规模和约定 对于30%的数据，1&lt;=n&lt;=20，1&lt;=m&lt;=100； 对于50%的数据，1&lt;=n&lt;=500，1&lt;=m&lt;=10000； 对于100%的数据，1&lt;=n&lt;=10000，1&lt;=m&lt;=100000，1&lt;=a, b&lt;=n， 1&lt;=t&lt;=100000。 思路： 使用并查集，按损坏时间倒序添加路径。 AC代码: #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; struct node{ int s; int e; int t; }b[100010]; bool cmp(node a,node b) { return a.t &gt; b.t; } int a[10001] = {0}; int find(int x) { int tx = x; int root; while(a[tx] != tx) { tx = a[tx]; } root = tx; while(a[x] != root) { tx = a[x]; a[x] = root; x = tx; } return root; } bool Union(int x,int y) { int tx = find(x); int ty = find(y); if(tx != ty) { a[tx] = ty; return true; } return false; } int n,m; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;,&amp;b[i].s,&amp;b[i].e,&amp;b[i].t); } sort(b + 1, b + m + 1,cmp); for(int i = 1; i &lt;= n; i++) { a[i] = i; } int cnt = 0; int last = 0; for(int i = 1; i &lt;= m; i++) { if(Union(b[i].s,b[i].e) &amp;&amp; last != b[i].t) { last = b[i].t; cnt++; } } cout &lt;&lt; cnt; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://lossherl.club/tags/蓝桥杯/"}]},{"title":"蓝桥杯 历届试题 最大子阵","date":"2017-03-17T14:52:47.000Z","path":"2017/03/17/蓝桥杯-历届试题-最大子阵/","text":"问题描述 给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。 其中，A的子矩阵指在A中行和列均连续的一块。 输入格式 输入的第一行包含两个整数n, m，分别表示矩阵A的行数和列数。 接下来n行，每行m个整数，表示矩阵A。输出格式 输出一行，包含一个整数，表示A中最大的子矩阵中的元素和。样例输入3 3-1 -4 33 4 -1-5 -2 8样例输出10样例说明 取最后一列，和为10。数据规模和约定 对于50%的数据，1&lt;=n, m&lt;=50； 思路： 逐行递推，再逐列扫描最大值。 AC代码： #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; long long a[501][501] = {0}; long long dp[501][501] = {0}; long long b[501] = {0}; int main() { int n,m; long long ans = -999999; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { cin &gt;&gt; a[i][j]; dp[i][j] = a[i][j] + dp[i][j - 1]; } } for(int i = 0; i &lt;= m; i++) { for(int j = i + 1; j &lt;= m; j++) { for(int k = 1; k &lt;= n; k++) { b[k] = dp[k][j] - dp[k][i]; } b[0] = 0; for(int k = 1; k &lt;= n; k++) { if(b[k - 1] &gt; 0) b[k] = b[k] + b[k - 1]; if(b[k] &gt; ans) ans = b[k]; } } } cout &lt;&lt; ans; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://lossherl.club/tags/蓝桥杯/"}]},{"title":"LeetCode 141.Linked List Cycle","date":"2017-03-17T14:26:50.000Z","path":"2017/03/17/LeetCode-141-Linked-List-Cycle/","text":"Description: Given a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? 使用双指针，一个每次走一步，另一个每次走两步，若存在环，指针将出现相等的情况。 代码: class Solution { public: bool hasCycle(ListNode *head) { ListNode *p1 = head; ListNode *p2 = head; while(p2 &amp;&amp; p2-&gt;next){ p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; if(p1 == p2) return true; } return false; } };","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://lossherl.club/tags/LeetCode/"}]},{"title":"LeetCode 221.Maximal square","date":"2017-03-17T14:17:50.000Z","path":"2017/03/17/LeetCode-221-Maximal-square/","text":"Description: Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. For example, given the following matrix: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Return 4. 动态规划可解 代码: class Solution { public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int n = matrix.size(); if(n == 0) return 0; int m = matrix[0].size(); if(m == 0) return 0; int ans = 0; vector&lt;vector&lt;int&gt;&gt; dp(n + 1); for(int i = 0; i &lt; dp.size(); i++) { dp[i].resize(m + 1); } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { if(matrix[i - 1][j - 1] == &apos;1&apos;) { dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1; } ans = max(ans,dp[i][j]); } } return ans * ans; } };","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://lossherl.club/tags/LeetCode/"}]},{"title":"CSP第九次认证 压缩编码","date":"2017-03-06T11:56:25.000Z","path":"2017/03/06/CSP第九次认证-压缩编码/","text":"问题描述 给定一段文字，已知单词a1, a2, …, an出现的频率分别t1, t2, …, tn。可以用01串给这些单词编码，即将每个单词与一个01串对应，使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。 使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为： L=a1的编码长度×t1+a2的编码长度×t2+…+ an的编码长度×tn。 定义一个前缀编码为字典序编码，指对于1 ≤ i &lt; n，ai的编码（对应的01串）的字典序在ai+1编码之前，即a1, a2, …, an的编码是按字典序升序排列的。 例如，文字E A E C D E B C C E C B D B E中， 5个单词A、B、C、D、E出现的频率分别为1, 3, 4, 2, 5，则一种可行的编码方案是A:000, B:001, C:01, D:10, E:11，对应的编码后的01串为1100011011011001010111010011000111，对应的长度L为3×1+3×3+2×4+2×2+2×5=34。 在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是A:000, B:01, C:10, D:001, E:11，虽然最终文字编码后的总长度只有33，但是这个编码不满足字典序编码的性质，比如C的编码的字典序不在D的编码之前。 在这个例子中，有些人可能会想的另一个字典序编码是A:000, B:001, C:010, D:011, E:1，编码后的文字长度为35。 请找出一个字典序编码，使得文字经过编码后的长度L最小。在输出时，你只需要输出最小的长度L，而不需要输出具体的方案。在上面的例子中，最小的长度L为34。输入格式 输入的第一行包含一个整数n，表示单词的数量。 第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an出现的频率，即t1, t2, …, tn。请注意a1, a2, …, an具体是什么单词并不影响本题的解，所以没有输入a1, a2, …, an。输出格式 输出一个整数，表示文字经过编码后的长度L的最小值。样例输入 5 1 3 4 2 5样例输出 34 样例说明 这个样例就是问题描述中的例子。如果你得到了35，说明你算得有问题，请自行检查自己的算法而不要怀疑是样例输出写错了。评测用例规模与约定 对于30%的评测用例，1 ≤ n ≤ 10，1 ≤ ti ≤ 20； 对于60%的评测用例，1 ≤ n ≤ 100，1 ≤ ti ≤ 100； 对于100%的评测用例，1 ≤ n ≤ 1000，1 ≤ ti ≤ 10000。 动态规划，等同于石子归并问题。 代码： #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; long long dp[1001][1001] = {0}; long long sum[1001] = {0}; int main() { int n; cin &gt;&gt; n; sum[0] = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; sum[i]; sum[i] += sum[i - 1]; dp[i][i] = 0; } for(int len = 2; len &lt;= n; len++) { for(int i = 1; i &lt;= n - len + 1; i++) { int j = i + len - 1; long long mmin = 9999999999; int tsum = sum[j] - sum[i - 1]; for(int k = i; k &lt; j; k++) { mmin = min(mmin,dp[i][k] + dp[k + 1][j] + tsum); } dp[i][j] = mmin; } } cout &lt;&lt; dp[1][n] &lt;&lt; endl; return 0; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"CSP","slug":"CSP","permalink":"http://lossherl.club/tags/CSP/"}]}]