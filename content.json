[{"title":"论文阅读笔记-Deep learning based RecSys utilizing visual content(1)","date":"2019-04-04T02:02:03.000Z","path":"2019/04/04/论文阅读笔记-Deep-learning-based-RecSys-utilizing-visual-content-1/","text":"参考文献[1] Zhou J, Albatal R, Gurrin C. Applying Visual User Interest Profiles for Recommendation and Personalisation.[J]. 2016.[2] Lei C , Liu D , Li W , et al. Comparative Deep Learning of Hybrid Representations for Image Recommendations[J]. 2016. Applying Visual User Interest Profiles for Recommendation and Personalisation介绍文献[1]认为用户的兴趣偏好可以从其曾经发布的照片中获取，通过使用深度学习中的技术从图片集中获取用户的视觉偏好信息，并用于酒店推荐及页面个性化定制。 视觉特征提取在基于内容的图片检索领域中，一些诸如颜色、文本等低级语义信息被用于表示图像以及计算图像相似度，但是这些低级语义并不能很好地表示用户偏好。文献[1]假设通过结合深度学习，对用户特征进行更高语义层面的提取将使得基于内容的推荐更加有效。文章中的方法利用AlexNet对图像作特征提取，将分类结果（1000个类别的概率分布）作为图像特征。用户偏好档案由多个图像的特征表示组成。 利用用户偏好文章使用余弦距离作图片间的相似度估计，如公式(1)所示。因此，通过计算用户偏好档案中的图像特征向量与其余图像的特征向量的相似度，获得与用户偏好相近的图片。 应用应用于酒店推荐以及酒店页面个性化定制。","tags":[{"name":"RecSys","slug":"RecSys","permalink":"http://lossherl.club/tags/RecSys/"},{"name":"User preference modeling","slug":"User-preference-modeling","permalink":"http://lossherl.club/tags/User-preference-modeling/"}]},{"title":"hihoCoder 1290 Demo Day","date":"2017-03-22T16:25:25.000Z","path":"2017/03/23/hihoCoder-1290-Demo-Day/","text":"描述You work as an intern at a robotics startup. Today is your company’s demo day. During the demo your company’s robot will be put in a maze and without any information about the maze, it should be able to find a way out. The maze consists of N * M grids. Each grid is either empty(represented by ‘.’) or blocked by an obstacle(represented by ‘b’). The robot will be release at the top left corner and the exit is at the bottom right corner. Unfortunately some sensors on the robot go crazy just before the demo starts. As a result, the robot can only repeats two operations alternatively: keep moving to the right until it can’t and keep moving to the bottom until it can’t. At the beginning, the robot keeps moving to the right. rrrrbb..…r…. ====&gt; The robot route with broken sensors is marked by ‘r’.…rrb..…bb…While the FTEs(full-time employees) are busy working on the sensors, you try to save the demo day by rearranging the maze in such a way that even with the broken sensors the robot can reach the exit successfully. You can change a grid from empty to blocked and vice versa. So as not to arouse suspision, you want to change as few grids as possible. What is the mininum number? 输入Line 1: N, M. Line 2-N+1: the N * M maze. For 20% of the data, N * M &lt;= 16. For 50% of the data, 1 &lt;= N, M &lt;= 8. For 100% of the data, 1&lt;= N, M &lt;= 100. 输出The minimum number of grids to be changed. 样例输入4 8….bb..……..…..b..…bb…样例输出1 思路： 动态规划，dp[i][j][k]表示到达(i,j)点以k方向前进最小所需做改变的次数。 代码: #include &lt;iostream&gt; using namespace std; int m,n; bool map[110][110] = {0}; int dp[110][110][2] = {0}; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { char c; cin &gt;&gt; c; if(c == &apos;.&apos;) { map[i][j] = true; } } } for(int i = 0; i &lt;= n; i++) { for(int j = 0; j &lt;= m; j++) { dp[i][j][0] = dp[i][j][1] = 999999; } } dp[1][1][0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { for(int k = 0; k &lt; 2; k++) { if(map[i][j]) { if(k) { dp[i][j][k] = min(dp[i][j][k],dp[i - 1][j][k]); if(!map[i + 1][j]) { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k]); } else { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k] + 1); } } else { dp[i][j][k] = min(dp[i][j][k],dp[i][j - 1][k]); if(!map[i][j + 1]) { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k]); } else { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k] + 1); } } } else { if(k) { dp[i][j][k] = min(dp[i][j][k],dp[i - 1][j][k] + 1); if(!map[i + 1][j]) { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k]); } else { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k] + 1); } } else { dp[i][j][k] = min(dp[i][j][k],dp[i][j - 1][k] + 1); if(!map[i][j + 1]) { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k]); } else { dp[i][j][1 - k] = min(dp[i][j][1 - k],dp[i][j][k] + 1); } } } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; dp[i][j][k] &lt;&lt; endl; } } } cout &lt;&lt; min(dp[n][m][0],dp[n][m][1]) &lt;&lt; endl; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://lossherl.club/tags/hihoCoder/"}]},{"title":"hihoCoder 1238 Total Highway Distance","date":"2017-03-21T14:28:30.000Z","path":"2017/03/21/hihoCoder-1238-Total-Highway-Distance/","text":"时间限制:10000ms单点时限:1000ms内存限制:256MB描述Little Hi and Little Ho are playing a construction simulation game. They build N cities (numbered from 1 to N) in the game and connect them by N-1 highways. It is guaranteed that each pair of cities are connected by the highways directly or indirectly. The game has a very important value called Total Highway Distance (THD) which is the total distances of all pairs of cities. Suppose there are 3 cities and 2 highways. The highway between City 1 and City 2 is 200 miles and the highway between City 2 and City 3 is 300 miles. So the THD is 1000(200 + 500 + 300) miles because the distances between City 1 and City 2, City 1 and City 3, City 2 and City 3 are 200 miles, 500 miles and 300 miles respectively. During the game Little Hi and Little Ho may change the length of some highways. They want to know the latest THD. Can you help them? 输入Line 1: two integers N and M. Line 2 .. N: three integers u, v, k indicating there is a highway of k miles between city u and city v. Line N+1 .. N+M: each line describes an operation, either changing the length of a highway or querying the current THD. It is in one of the following format. EDIT i j k, indicating change the length of the highway between city i and city j to k miles. QUERY, for querying the THD. For 30% of the data: 2&lt;=N&lt;=100, 1&lt;=M&lt;=20 For 60% of the data: 2&lt;=N&lt;=2000, 1&lt;=M&lt;=20 For 100% of the data: 2&lt;=N&lt;=100,000, 1&lt;=M&lt;=50,000, 1 &lt;= u, v &lt;= N, 0 &lt;= k &lt;= 1000. 输出For each QUERY operation output one line containing the corresponding THD. 样例输入3 51 2 22 3 3QUERYEDIT 1 2 4QUERYEDIT 2 3 2QUERY样例输出101412 思路： 两次深搜计算每条路径经过的次数。 代码： #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cstdio&gt; using namespace std; typedef struct p{ int cur; vector&lt;int&gt; v; p(int c) { cur = c; } }p; typedef struct ar{ int to; int index; ar(int t,int i) { to = t; index = i; } }ar; typedef struct arcc{ int f; int t; int v; }arcc; vector&lt;ar&gt; a[100010]; bool vi[100010] = {0}; arcc arc[100010]; long long arc_c[100010] = {0}; int n,m; int child[100010] = {0}; long long query() { long long ans = 0; for(int i = 1; i &lt; n; i++) { ans += arc[i].v * arc_c[i]; } return ans; } void dfs(int x,int f) { child[x] = 1; for(int i = 0; i &lt; a[x].size(); i++) { if(a[x][i].to == f) continue; dfs(a[x][i].to,x); child[x] += child[a[x][i].to]; } } void dfs1(int x,int f) { for(int i = 0; i &lt; a[x].size(); i++) { if(a[x][i].to == f) continue; arc_c[a[x][i].index] = (long long) child[a[x][i].to] * (long long)(n - child[a[x][i].to]); dfs1(a[x][i].to,x); } } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt; n; i++) { int f,t,v; scanf(&quot;%d %d %d&quot;,&amp;f,&amp;t,&amp;v); arc[i].v = v; arc[i].f = f; arc[i].t = t; a[f].push_back(ar(t,i)); a[t].push_back(ar(f,i)); } dfs(1,0); dfs1(1,0); // for(int i = 1; i &lt; n; i++) // cout &lt;&lt; arc_c[i] &lt;&lt; endl; string cmd; long long ans = query(); for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; cmd; if(cmd == &quot;QUERY&quot;) { printf(&quot;%lld\\n&quot;,ans); } else { int f,t,v; scanf(&quot;%d %d %d&quot;,&amp;f,&amp;t,&amp;v); for(int j = 0; j &lt; a[f].size(); j++) { if(a[f][j].to == t) { ans += arc_c[a[f][j].index] * (v - arc[a[f][j].index].v); arc[a[f][j].index].v = v; break; } } } } }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://lossherl.club/tags/hihoCoder/"}]},{"title":"hihoCoder 1399 Shortening Sequence","date":"2017-03-21T14:25:14.000Z","path":"2017/03/21/hihoCoder-1399-Shortening-Sequence/","text":"时间限制:10000ms单点时限:1000ms内存限制:256MB描述There is an integer array A1, A2 …AN. Each round you may choose two adjacent integers. If their sum is an odd number, the two adjacent integers can be deleted. Can you work out the minimum length of the final array after elaborate deletions? 输入The first line contains one integer N, indicating the length of the initial array. The second line contains N integers, indicating A1, A2 …AN. For 30% of the data：1 ≤ N ≤ 10 For 60% of the data：1 ≤ N ≤ 1000 For 100% of the data：1 ≤ N ≤ 1000000, 0 ≤ Ai ≤ 1000000000 输出One line with an integer indicating the minimum length of the final array. 样例提示(1,2) (3,4) (4,5) are deleted. 样例输入71 1 2 3 4 4 5样例输出1 思路： 动态规划，线性扫描并枚举26个字母。 代码: #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; using namespace std; //strucc p{ // int cur; // int last; // int len; //}dp[1000001]; int n; int main() { cin &gt;&gt; n; vector&lt;int&gt; v; int t; scanf(&quot;%d&quot;,&amp;t); v.push_back(t); for(int i = 2; i &lt;= n; i++) { scanf(&quot;%d&quot;,&amp;t); if(v.size() == 0) { v.push_back(t); continue; } if((t ^ v[v.size() - 1]) &amp; 1) { v.erase(v.end() - 1); } else v.push_back(t); } cout &lt;&lt; v.size(); }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://lossherl.club/tags/hihoCoder/"}]},{"title":"hihoCoder 1288 Font Size","date":"2017-03-21T14:21:08.000Z","path":"2017/03/21/hihoCoder-1288-Font-Size/","text":"时间限制:10000ms单点时限:1000ms内存限制:256MB描述Steven loves reading book on his phone. The book he reads now consists of N paragraphs and the i-th paragraph contains ai characters. Steven wants to make the characters easier to read, so he decides to increase the font size of characters. But the size of Steven’s phone screen is limited. Its width is W and height is H. As a result, if the font size of characters is S then it can only show ⌊W / S⌋ characters in a line and ⌊H / S⌋ lines in a page. (⌊x⌋ is the largest integer no more than x) So here’s the question, if Steven wants to control the number of pages no more than P, what’s the maximum font size he can set? Note that paragraphs must start in a new line and there is no empty line between paragraphs. 输入Input may contain multiple test cases. The first line is an integer TASKS, representing the number of test cases. For each test case, the first line contains four integers N, P, W and H, as described above. The second line contains N integers a1, a2, … aN, indicating the number of characters in each paragraph. For all test cases, 1 &lt;= N &lt;= 103, 1 &lt;= W, H, ai &lt;= 103, 1 &lt;= P &lt;= 106, There is always a way to control the number of pages no more than P. 输出For each testcase, output a line with an integer Ans, indicating the maximum font size Steven can set. 样例输入21 10 4 3102 10 4 310 10样例输出32 思路： 二分搜索。 代码： #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;queue&gt; using namespace std; int task; int w,h,p; int n; int a[1001] = {0}; int main() { cin &gt;&gt; task; for(int z = 1; z &lt;= task; z++) { cin &gt;&gt; n &gt;&gt; p &gt;&gt; w &gt;&gt; h; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int l = 1; int r = min(w,h); int mid; int last; while(l &lt;= r) { mid = (l + r) / 2; int line = h / mid; int wid = w / mid; int count = 0; for(int j = 1; j &lt;= n; j++) { count += a[j] / wid; if(a[j] % wid) count++; } if(count &lt;= p * line) { last = mid; l = mid + 1; } else { r = mid - 1; } } cout &lt;&lt; last &lt;&lt; endl; } }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://lossherl.club/tags/hihoCoder/"}]},{"title":"蓝桥杯 历届试题 小朋友排队","date":"2017-03-17T15:04:42.000Z","path":"2017/03/17/蓝桥杯-历届试题-小朋友排队/","text":"问题描述 n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。 每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。 如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。 请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。 如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。输入格式 输入的第一行包含一个整数n，表示小朋友的个数。 第二行包含 n 个整数 H1 H2 … Hn，分别表示每个小朋友的身高。输出格式 输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。样例输入33 2 1样例输出9样例说明 首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。数据规模和约定 对于10%的数据， 1&lt;=n&lt;=10； 对于30%的数据， 1&lt;=n&lt;=1000； 对于50%的数据， 1&lt;=n&lt;=10000； 对于100%的数据，1&lt;=n&lt;=100000，0&lt;=Hi&lt;=1000000。 思路： 逆序数+树状数组，每个点左边大于它的个数加上右边小于它的个数等于交换的总次数，使用树状数组统计。 AC代码： #include &lt;iostream&gt; using namespace std; #define N 100100 #define MAX 1000100 int a[MAX] = {0}; int b[MAX] = {0}; int c[N] = {0}; int num[N] = {0}; long long total[N] = {0}; int n; int lowbit(int x) { return x&amp;(-x); } void add(int pos,int *p) { while(pos &lt;= MAX) { p[pos]++; pos += lowbit(pos); } } int sum(int pos,int *p) { int cnt = 0; while(pos &gt; 0) { cnt += p[pos]; pos -= lowbit(pos); } return cnt; } void Init() { for(int i = 1; i &lt;= n; i++) { total[i] = total[i - 1] + i; } } int main() { cin &gt;&gt; n; Init(); for(int i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; add(num[i] + 1,a); c[i] = i - sum(num[i],a); c[i] -= sum(num[i] + 1,a) - sum(num[i],a) - 1; } long long ans = 0; for(int i = n - 1; i &gt;= 0; i--) { add(num[i] + 1,b); c[i] += sum(num[i],b); ans += total[c[i]]; } cout &lt;&lt; ans; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://lossherl.club/tags/蓝桥杯/"}]},{"title":"蓝桥杯 历届试题 高僧斗法","date":"2017-03-17T15:00:48.000Z","path":"2017/03/17/蓝桥杯-历届试题-高僧斗法/","text":"问题描述 古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。 节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。(如图1所示) 两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。 两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。 对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。 输入格式 输入数据为一行用空格分开的N个整数，表示小和尚的位置。台阶序号从1算起，所以最后一个小和尚的位置即是台阶的总数。（N&lt;100, 台阶总数&lt;1000）输出格式 输出为一行用空格分开的两个整数: A B, 表示把A位置的小和尚移动到B位置。若有多个解，输出A值较小的解，若无解则输出-1。样例输入1 5 9样例输出1 4样例输入1 5 8 10样例输出1 3 思路： Nim游戏的变形，每个小和尚之间的台阶即为Nim游戏中的单堆石子数。 AC代码： #include &lt;iostream&gt; using namespace std; int a[101] = {0}; int b[101] = {0}; int main() { int i; int n; int sum = 0; while(cin &gt;&gt; i) { n++; a[n] = i; } for(i = 1; i &lt;= n / 2; i++) { b[i] = a[2 * i] - a[2 * i - 1] - 1; } for(i = 1; i &lt;= n / 2; i++) { sum ^= b[i]; } if(sum == 0) cout &lt;&lt; -1; else { for(i = 1; i &lt;= n; i++) { for(int j = 1; j &lt; a[i + 1] - a[i]; j++) { a[i] += j; sum = 0; for(int k = 1; k &lt;= n / 2; k++) { b[k] = a[2 * k] - a[2 * k - 1] - 1; sum ^= b[k]; } if(sum == 0) { cout &lt;&lt; a[i] - j &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; endl; break; } a[i] -= j; } } } }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://lossherl.club/tags/蓝桥杯/"}]},{"title":"蓝桥杯 历届试题 国王的烦恼","date":"2017-03-17T14:57:12.000Z","path":"2017/03/17/蓝桥杯-历届试题-国王的烦恼/","text":"问题描述 C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。 如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。 现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。输入格式 输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。 接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。输出格式 输出一个整数，表示居民们会抗议的天数。样例输入4 41 2 21 3 22 3 13 4 3样例输出2样例说明 第一天后2和3之间的桥不能使用，不影响。 第二天后1和2之间，以及1和3之间的桥不能使用，居民们会抗议。 第三天后3和4之间的桥不能使用，居民们会抗议。数据规模和约定 对于30%的数据，1&lt;=n&lt;=20，1&lt;=m&lt;=100； 对于50%的数据，1&lt;=n&lt;=500，1&lt;=m&lt;=10000； 对于100%的数据，1&lt;=n&lt;=10000，1&lt;=m&lt;=100000，1&lt;=a, b&lt;=n， 1&lt;=t&lt;=100000。 思路： 使用并查集，按损坏时间倒序添加路径。 AC代码: #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; struct node{ int s; int e; int t; }b[100010]; bool cmp(node a,node b) { return a.t &gt; b.t; } int a[10001] = {0}; int find(int x) { int tx = x; int root; while(a[tx] != tx) { tx = a[tx]; } root = tx; while(a[x] != root) { tx = a[x]; a[x] = root; x = tx; } return root; } bool Union(int x,int y) { int tx = find(x); int ty = find(y); if(tx != ty) { a[tx] = ty; return true; } return false; } int n,m; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;,&amp;b[i].s,&amp;b[i].e,&amp;b[i].t); } sort(b + 1, b + m + 1,cmp); for(int i = 1; i &lt;= n; i++) { a[i] = i; } int cnt = 0; int last = 0; for(int i = 1; i &lt;= m; i++) { if(Union(b[i].s,b[i].e) &amp;&amp; last != b[i].t) { last = b[i].t; cnt++; } } cout &lt;&lt; cnt; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://lossherl.club/tags/蓝桥杯/"}]},{"title":"蓝桥杯 历届试题 最大子阵","date":"2017-03-17T14:52:47.000Z","path":"2017/03/17/蓝桥杯-历届试题-最大子阵/","text":"问题描述 给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。 其中，A的子矩阵指在A中行和列均连续的一块。 输入格式 输入的第一行包含两个整数n, m，分别表示矩阵A的行数和列数。 接下来n行，每行m个整数，表示矩阵A。输出格式 输出一行，包含一个整数，表示A中最大的子矩阵中的元素和。样例输入3 3-1 -4 33 4 -1-5 -2 8样例输出10样例说明 取最后一列，和为10。数据规模和约定 对于50%的数据，1&lt;=n, m&lt;=50； 思路： 逐行递推，再逐列扫描最大值。 AC代码： #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; long long a[501][501] = {0}; long long dp[501][501] = {0}; long long b[501] = {0}; int main() { int n,m; long long ans = -999999; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { cin &gt;&gt; a[i][j]; dp[i][j] = a[i][j] + dp[i][j - 1]; } } for(int i = 0; i &lt;= m; i++) { for(int j = i + 1; j &lt;= m; j++) { for(int k = 1; k &lt;= n; k++) { b[k] = dp[k][j] - dp[k][i]; } b[0] = 0; for(int k = 1; k &lt;= n; k++) { if(b[k - 1] &gt; 0) b[k] = b[k] + b[k - 1]; if(b[k] &gt; ans) ans = b[k]; } } } cout &lt;&lt; ans; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://lossherl.club/tags/蓝桥杯/"}]},{"title":"LeetCode 141.Linked List Cycle","date":"2017-03-17T14:26:50.000Z","path":"2017/03/17/LeetCode-141-Linked-List-Cycle/","text":"Description: Given a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? 使用双指针，一个每次走一步，另一个每次走两步，若存在环，指针将出现相等的情况。 代码: class Solution { public: bool hasCycle(ListNode *head) { ListNode *p1 = head; ListNode *p2 = head; while(p2 &amp;&amp; p2-&gt;next){ p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; if(p1 == p2) return true; } return false; } };","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://lossherl.club/tags/LeetCode/"}]},{"title":"LeetCode 221.Maximal square","date":"2017-03-17T14:17:50.000Z","path":"2017/03/17/LeetCode-221-Maximal-square/","text":"Description: Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. For example, given the following matrix: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Return 4. 动态规划可解 代码: class Solution { public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int n = matrix.size(); if(n == 0) return 0; int m = matrix[0].size(); if(m == 0) return 0; int ans = 0; vector&lt;vector&lt;int&gt;&gt; dp(n + 1); for(int i = 0; i &lt; dp.size(); i++) { dp[i].resize(m + 1); } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { if(matrix[i - 1][j - 1] == &apos;1&apos;) { dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1; } ans = max(ans,dp[i][j]); } } return ans * ans; } };","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://lossherl.club/tags/LeetCode/"}]},{"title":"CSP第九次认证 压缩编码","date":"2017-03-06T11:56:25.000Z","path":"2017/03/06/CSP第九次认证-压缩编码/","text":"问题描述 给定一段文字，已知单词a1, a2, …, an出现的频率分别t1, t2, …, tn。可以用01串给这些单词编码，即将每个单词与一个01串对应，使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。 使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为： L=a1的编码长度×t1+a2的编码长度×t2+…+ an的编码长度×tn。 定义一个前缀编码为字典序编码，指对于1 ≤ i &lt; n，ai的编码（对应的01串）的字典序在ai+1编码之前，即a1, a2, …, an的编码是按字典序升序排列的。 例如，文字E A E C D E B C C E C B D B E中， 5个单词A、B、C、D、E出现的频率分别为1, 3, 4, 2, 5，则一种可行的编码方案是A:000, B:001, C:01, D:10, E:11，对应的编码后的01串为1100011011011001010111010011000111，对应的长度L为3×1+3×3+2×4+2×2+2×5=34。 在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是A:000, B:01, C:10, D:001, E:11，虽然最终文字编码后的总长度只有33，但是这个编码不满足字典序编码的性质，比如C的编码的字典序不在D的编码之前。 在这个例子中，有些人可能会想的另一个字典序编码是A:000, B:001, C:010, D:011, E:1，编码后的文字长度为35。 请找出一个字典序编码，使得文字经过编码后的长度L最小。在输出时，你只需要输出最小的长度L，而不需要输出具体的方案。在上面的例子中，最小的长度L为34。输入格式 输入的第一行包含一个整数n，表示单词的数量。 第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an出现的频率，即t1, t2, …, tn。请注意a1, a2, …, an具体是什么单词并不影响本题的解，所以没有输入a1, a2, …, an。输出格式 输出一个整数，表示文字经过编码后的长度L的最小值。样例输入 5 1 3 4 2 5样例输出 34 样例说明 这个样例就是问题描述中的例子。如果你得到了35，说明你算得有问题，请自行检查自己的算法而不要怀疑是样例输出写错了。评测用例规模与约定 对于30%的评测用例，1 ≤ n ≤ 10，1 ≤ ti ≤ 20； 对于60%的评测用例，1 ≤ n ≤ 100，1 ≤ ti ≤ 100； 对于100%的评测用例，1 ≤ n ≤ 1000，1 ≤ ti ≤ 10000。 动态规划，等同于石子归并问题。 代码： #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; long long dp[1001][1001] = {0}; long long sum[1001] = {0}; int main() { int n; cin &gt;&gt; n; sum[0] = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; sum[i]; sum[i] += sum[i - 1]; dp[i][i] = 0; } for(int len = 2; len &lt;= n; len++) { for(int i = 1; i &lt;= n - len + 1; i++) { int j = i + len - 1; long long mmin = 9999999999; int tsum = sum[j] - sum[i - 1]; for(int k = i; k &lt; j; k++) { mmin = min(mmin,dp[i][k] + dp[k + 1][j] + tsum); } dp[i][j] = mmin; } } cout &lt;&lt; dp[1][n] &lt;&lt; endl; return 0; }","tags":[{"name":"题解","slug":"题解","permalink":"http://lossherl.club/tags/题解/"},{"name":"CSP","slug":"CSP","permalink":"http://lossherl.club/tags/CSP/"}]}]